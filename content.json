{"meta":{"title":"航的个人站","subtitle":"抬眼之处仍是少年出世之身","description":"","author":"航","url":"http://yuhang-blog.github.io","root":"/"},"pages":[{"title":"关于我","date":"2021-07-31T06:44:25.000Z","updated":"2022-04-01T16:12:41.624Z","comments":true,"path":"about/index.html","permalink":"http://yuhang-blog.github.io/about/index.html","excerpt":"","text":"电子信息工程专业 2021年毕业，目前工作于深圳 偶尔听听音乐，喜欢JJLIN的《和自己对话》之后的专辑"}],"posts":[{"title":"test_2022_4_2","slug":"test-2022-4-2","date":"2022-04-02T09:15:30.000Z","updated":"2022-04-02T09:16:08.612Z","comments":true,"path":"2022/04/02/test-2022-4-2/","link":"","permalink":"http://yuhang-blog.github.io/2022/04/02/test-2022-4-2/","excerpt":"","text":"this is test!!!","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://yuhang-blog.github.io/tags/test/"}]},{"title":"实时操作系统中如何创建无数个定时任务","slug":"timer","date":"2022-03-29T06:30:49.000Z","updated":"2022-03-30T10:13:19.931Z","comments":true,"path":"2022/03/29/timer/","link":"","permalink":"http://yuhang-blog.github.io/2022/03/29/timer/","excerpt":"硬件定时器与软件定时器在裸机开发中，创建定时任务一般使用的是硬件定时器，一般一个定时任务就占用一个硬件定时器，然而硬件定时器有限。不管是我使用过的华为LiteOS还是FreeRTOS，这些嵌入式实时操作系统都有软件定时器这一模块，实现方式都差不多，有了软件定时器，就可以搭配消息队列实现创建无数个定时任务。","text":"硬件定时器与软件定时器在裸机开发中，创建定时任务一般使用的是硬件定时器，一般一个定时任务就占用一个硬件定时器，然而硬件定时器有限。不管是我使用过的华为LiteOS还是FreeRTOS，这些嵌入式实时操作系统都有软件定时器这一模块，实现方式都差不多，有了软件定时器，就可以搭配消息队列实现创建无数个定时任务。 硬件定时器 芯片本身提供的定时功能，精度与系统时钟周期有关，精度很高 每次在定时时间到达之后自动触发一个中断，用户在中断服务函数中处理消息 软件定时器 超时函数提供的定时功能，精度与系统节拍周期有关，精度不高 指定时间到达后调用回调函数，用户在回调函数中处理消息 软件定时器底层实现方式软件定时器底层实现方式简单来讲就是，创建了两个列表和一个消息队列，根据系统节拍获取最近一次定时器超时的时间。 列表的功能 两个列表一个为当前定时器列表，另一个为溢出定时器列表。当系统节拍溢出，当前定时器列表变为溢出定时器列表，溢出定时器列表变为当前定时器列表，并调用一次回调函数 消息队列的功能 此消息队列为定时器命令队列，接收到命令去处理对应的程序，比如定时器的开启，停止，复位，删除，改变周期等。嵌入式操作系统提供的定时器的开启，停止，复位，删除，改变周期等函数其实就是向定时器命令队列发送命令 以FreeRTOS为例，软件定时器实现的代码框架如下： 封装成应用层软件定时器以FreeRTOS为例，软件定时器的创建，启动，停止的API如下： 1234567TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction );xTimerStart( xTimer, xTicksToWait )xTimerStop( xTimer, xTicksToWait ) 创建一个软件定时器，就需要创建一个软件定时器回调函数，创建无数个软件定时器，有无数个软件定时器回调函数，而且软件定时器的回调函数中应快进快出，不允许出现死循环，不允许使用引起软件定时器任务挂起或者引起阻塞的API。可以将这些实时操作系统提供的软件定时器模块重新封装变成应用层的软件定时器。将软件定时器的创建API和启动API封装成应用层软件定时器启动，入口参数不需要回调函数，将软件定时器停止封装成应用层软件定时器停止，入口参数从句柄改成软件定时器ID，让所有的软件定时器共用一个回调函数，这个回调函数的作用只是将软件定时器的ID发送到消息队列中。 应用层软件定时器的简单封装思路如下： 应用层软件定时器使用方式想要使用定时功能，只要先枚举出功能名，然后在case里面添加具体功能，再使用应用层软件定时器启动即枚举的功能名即可。 这里只是简单地提供利用嵌入式实时操作系统提供的软件定时器及消息队列模块实现创建无数个定时任务的思路。 written by：航&#x2F;2022&#x2F;3&#x2F;29","categories":[],"tags":[{"name":"LiteOS","slug":"LiteOS","permalink":"http://yuhang-blog.github.io/tags/LiteOS/"},{"name":"FreeRTOS","slug":"FreeRTOS","permalink":"http://yuhang-blog.github.io/tags/FreeRTOS/"}]},{"title":"浅谈回调函数","slug":"callback","date":"2022-02-27T12:53:33.000Z","updated":"2022-03-28T11:54:27.250Z","comments":true,"path":"2022/02/27/callback/","link":"","permalink":"http://yuhang-blog.github.io/2022/02/27/callback/","excerpt":"什么是回调函数在大型项目中，回调函数使用得非常普遍。什么是回调函数呢？初学者不清楚什么是回调函数，回调函数(Callback Functions)就是通过函数指针调用的函数。下面浅谈下回调函数","text":"什么是回调函数在大型项目中，回调函数使用得非常普遍。什么是回调函数呢？初学者不清楚什么是回调函数，回调函数(Callback Functions)就是通过函数指针调用的函数。下面浅谈下回调函数 理解回调函数通过以下几点来理解回调函数： 函数不加括号是什么 函数不加括号即是函数名，一个函数在内存中占据着一段连续的区域，函数名在表达式中会被转换成这段区域的首地址，此概念与数组差不多 指向函数的指针 什么是函数的指针，举个例子: 1void(*P)() 简单理解就是，第二个括号为一个函数，第一个括号中P为一个指针，这个函数为void类型，P是指向void类型函数的指针 函数作为参数进行传递 通过以上两点知道了函数的地址和函数的指针，这样就可以将函数作为参数进行传递了，举个例子： 1234567891011121314151617#include&lt;stdio.h&gt;void callback_print(void)&#123; printf(&quot;This is callback\\r\\n&quot;); &#125;void example(void(*callback)())&#123; callback();&#125;int main()&#123; example(callback_print); return 0;&#125; 运行结果如下： 1This is callback 可以看到成功将函数作为参数进行传递 回调函数的作用回调函数的最大优点就是解耦，软件设计的核心思想就是：解除耦合关系，降低耦合关系，原则就是A功能的代码不要写在B功能代码中，尽量做到模块化。使用回调函数即可将调用者和被调用者分开，调用者不需要了解谁是被调用者 written by：航&#x2F;2022&#x2F;2&#x2F;27","categories":[],"tags":[{"name":"callback","slug":"callback","permalink":"http://yuhang-blog.github.io/tags/callback/"},{"name":"C语言","slug":"C语言","permalink":"http://yuhang-blog.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"linux系统移植—主线kernel","slug":"kernel","date":"2021-12-27T09:53:45.000Z","updated":"2021-12-29T09:54:08.000Z","comments":true,"path":"2021/12/27/kernel/","link":"","permalink":"http://yuhang-blog.github.io/2021/12/27/kernel/","excerpt":"下载linux源码4.13版本的linux内核源码稳定可靠，下载4.13版本的linux内核源码","text":"下载linux源码4.13版本的linux内核源码稳定可靠，下载4.13版本的linux内核源码 1git clone -b zero-4.13.y https://github.com/Lichee-Pi/linux.git 修改顶层Makefile进入linux源码修改Makefile的250行和251行 12cd linuxvim Makefile 将分支改成arm分支，将交叉编译器改成之前安装的交叉编译器 内核配置使用荔枝派的配置文件 1make licheepi_zero_defconfig 安装此安装包进行菜单式配置 1sudo apt-get install libncurses5-dev 因添加了LCD屏，进入菜单配置进行勾选，从而支持st7789v驱动编译进内核 1make menuconfig 上下左右键选择，回车键进入下一级菜单，空格键为确认取消，依次进入菜单并勾选。 Device Drivers —&gt; [*] Staging drivers —&gt; &lt;*&gt; Support for small TFT LCD display modules —&gt; &lt;*&gt; FB driver for the ST7789V LCD Controller 修改st7789v驱动按此路径打开st7789v的驱动文件对其进行修改 linux&#x2F;drivers&#x2F;staging&#x2F;fbtft&#x2F;fb_st7789v.c 根据屏幕厂家给的STM32代码的屏幕初始化函数和linux内核源码自带的屏幕初始化函数进行融合修改，此为修改后的屏幕初始化函数 修改屏幕分辨率，找到fbtft_display display结构体，默认的分辨率大小为240*320即2寸屏，不用修改分辨率 修改设备树屏幕为SPI屏，因此需要创建SPI节点，并将st7789v驱动挂载在SPI的子节点上，并修改LED设备节点信息，按此路径打开设备树对其进行修改 linux&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;sun8i-v3s-licheepi-zero.dts 编译内核及设备树进入linux文件目录下，编译内核和设备树 12make -j16mkke dtbs 编译完成后，在这两个路径下会看到内核和设备树 linux&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;zImage linux&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;sun8i-v3s-licheepi-zero.dtb zImage和sun8i-v3s-licheepi-zero.dtb就是需要使用到的内核和设备树 结语内核和设备树搞定，接下来就是根文件系统 written by：航&#x2F;2021&#x2F;11&#x2F;23","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yuhang-blog.github.io/tags/linux/"}]},{"title":"ARM版MinDoc的搭建","slug":"mindoc","date":"2021-12-22T01:12:12.000Z","updated":"2021-12-29T08:43:56.000Z","comments":true,"path":"2021/12/22/mindoc/","link":"","permalink":"http://yuhang-blog.github.io/2021/12/22/mindoc/","excerpt":"简介MinDoc 是一款针对团队开发的简单好用的文档管理系统。官方没有ARM版的安装包，网上也没有编译ARM版MinDoc的教程，那只好自己尝试下在ARM开发板上对MinDoc源码进行编译","text":"简介MinDoc 是一款针对团队开发的简单好用的文档管理系统。官方没有ARM版的安装包，网上也没有编译ARM版MinDoc的教程，那只好自己尝试下在ARM开发板上对MinDoc源码进行编译 安装GO语言下载GO语言中文官网，可以看到里面有不同系统和不同处理器的GO语言安装包，复制linux-armv6l版的链接，在开发板上进行下载 1wget https://studygolang.com/dl/golang/go1.17.5.linux-armv6l.tar.gz 安装1sudo tar -C /usr/local -zvxf go1.17.5.linux-armv6l.tar.gz 修改环境变量直接在系统环境变量文件中追加GO语言路径 123sudo vim /etc/profile#文件末尾添加export PATH=$PATH:/usr/local/go/bin 验证版本能看到版本号就证明GO语言安装成功了 12source /etc/profilego version 安装MinDoc下载源码1git clone https://github.com/lifei6671/mindoc.git 下载依赖12cd mindocgo mod tidy 配置文件重命令1mv conf/app.conf.example conf/app.conf 编译1go build -o mindoc main.go 初始化数据库1./mindoc install 安装SQLite1sudo apt-get install sqlite3 进入数据库修改用户名系统默认的用户名为admin，想修改用户名就在数据库中修改 123456sqlite3 database/mindoc.db.tablesselect account from md_members;update md_members set account=&#x27;你的用户名&#x27; where account=&#x27;admin&#x27;;select account from md_members;.quit 启动启动之后，在浏览器输入开发板IP加上8181端口就可以使用MinDoc了，因没公网IP，想要外网访问MinDoc，那只好内网穿透了 1./mindoc written by：航&#x2F;2021&#x2F;12&#x2F;22","categories":[],"tags":[{"name":"MinDoc","slug":"MinDoc","permalink":"http://yuhang-blog.github.io/tags/MinDoc/"}]},{"title":"linux系统移植—主线Uboot及TF卡分区制作","slug":"Uboot","date":"2021-11-23T08:36:21.000Z","updated":"2021-12-29T09:49:50.000Z","comments":true,"path":"2021/11/23/Uboot/","link":"","permalink":"http://yuhang-blog.github.io/2021/11/23/Uboot/","excerpt":"前言linux系统移植的芯片为全志V3s，分为三大部分：Uboot，linux内核，根文件系统","text":"前言linux系统移植的芯片为全志V3s，分为三大部分：Uboot，linux内核，根文件系统 安装交叉编译器下载123wget https://releases.linaro.org/components/toolchain/binaries/latest/arm-linux-gnueabihf/gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf.tar.xztar xvf gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf.tar.xzmv gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf /usr/local/ 修改环境变量123sudo vim /etc/bash.bashrc#文件末尾添加export PATH=$PATH:/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin 验证版本1arm-linux-gnueabihf-gcc -v Uboot下载编译下载Uboot源码之后进行编译会在Uboot目录下生成名为“u-boot-sunxi-with-spl.bin”的二进制文件 12345git clone https://github.com/Lichee-Pi/u-boot.git -b v3s-currentcd u-bootmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_defconfig make ARCH=arm menuconfigtime make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- 2&gt;&amp;1 | tee build.log 烧录烧录之前首先要对TF卡进行分区制作，将Uboot目录下的“u-boot-sunxi-with-spl.bin”二进制文件烧录到SD卡的8K偏移处即可 1sdo dd if=u-boot-sunxi-with-spl.bin of=/dev/sdb bs=1024 seek=8 TF卡分区制作TF卡分区介绍 boot区 - 存放二进制的BootLoader linux内核区 - 存放linux内核及设备树dtb文件(fat16文件分区格式) rootfs分区 - 存放根文件系统(ext4文件分区格式) 分区操作GParted是linux系统的磁盘分区工具，插入一张格式化之后TF卡，打开GParted，新建一个32MB的fat16格式的分区，剩余大小创建成ext4格式的分区。 written by：航&#x2F;2021&#x2F;11&#x2F;23","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yuhang-blog.github.io/tags/linux/"}]},{"title":"带伞提示助手","slug":"weather","date":"2021-11-18T08:14:45.000Z","updated":"2021-11-26T12:35:40.000Z","comments":true,"path":"2021/11/18/weather/","link":"","permalink":"http://yuhang-blog.github.io/2021/11/18/weather/","excerpt":"起因说下我的痛点，遇到过很多次上班前天气很好但是下班出地铁口时开始下大雨，因没带雨伞等雨停等了许久。每天早起不一定会看天气，那能不能做一个提示助手每天进行提示？","text":"起因说下我的痛点，遇到过很多次上班前天气很好但是下班出地铁口时开始下大雨，因没带雨伞等雨停等了许久。每天早起不一定会看天气，那能不能做一个提示助手每天进行提示？ 解决方法不假思索的找到解决方法，Python爬虫+QQ邮箱+Ubuntu定时执行。建立一个爬虫脚本，将脚本放在我的个人服务器上，让Ubuntu每天执行三次，分别在起床前，乘坐地铁中和下班前，下雨天就在我起床前和下班前发邮件提示我带伞，不是下雨天就在我坐地铁中推送今日天气。这样，起床前看到邮件就要带伞了 爬虫获取天气进入中国天气网按F12找到天气和温度标签，可以看到今日天气在P标签中class&#x3D;”wea”中，最低温度class&#x3D;”wea”的P标签中的i标签中，最高温度在class&#x3D;”tem”的P标签中的span标签中，因中国天气网傍晚没有今日最高天气，爬取明天的最高温度当今日最高温度。 开始动手创建一个城市类，city_code为城市代码 12345678910111213141516171819202122class City: def __init__(self, city_code, receiver): self.city_code = city_code self.receiver = receiver headers = &#123;&#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36 Edg/89.0.774.68&#x27;&#125; url = &#x27;http://www.weather.com.cn/weather/&#x27; + self.city_code + &#x27;.shtml&#x27; res = requests.get(url, headers=headers) res.encoding = &#x27;utf-8&#x27; City.soup = BeautifulSoup(res.text, &#x27;html.parser&#x27;) City.tagToday = City.soup.find(&#x27;p&#x27;, class_=&quot;tem&quot;) def temperatureHigh(self): try: tempHigh = City.tagToday.span.string return tempHigh except AttributeError as e: tempHigh = City.tagToday.find_next(&#x27;p&#x27;, class_=&quot;tem&quot;).span.string return tempHigh def temperatureLow(self): tempLow = City.tagToday.i.string return tempLow 邮箱发送想要使用脚本登录QQ邮箱，首先要开启SMTP服务，按此操作开启SMTP服务并获取授权码 开始动手创建一个邮件类，account,password分别为发件人邮箱和授权码，receiver为收件人邮箱，可以自发自收 123456789101112class Email: def __init__(self, receiver, message): self.receiver = receiver self.message = message mailhost = &#x27;smtp.qq.com&#x27; Email.qqmail = smtplib.SMTP() Email.qqmail.connect(mailhost, 25) def Send_Email(self): Email.qqmail.login(account, password) Email.qqmail.sendmail(account, self.receiver, self.message) def Quit_Email(self): Email.qqmail.quit() 创建邮箱发送判定在城市类中创建邮箱发送判定函数，当爬取到的天气带“雨”且是起床前和下班前推送带伞邮件，当爬取的天气不带“雨”且在乘坐地铁则推送今日天气 1234567891011121314151617181920212223242526272829303132def Email_send_discriminant(self): time = datetime.datetime.now().strftime(&#x27;%H&#x27;) city_name = getDictKey(city_dict, self.city_code) if City.weather(self).text.find(u&quot;雨&quot;) != -1 or City.weather(self).text.find(u&quot;雾&quot;) != -1 or City.weather(self).text.find( u&quot;雹&quot;) != -1 or City.weather(self).text.find(u&quot;雪&quot;) != -1: if time == &quot;07&quot; or time == &quot;17&quot;: subject = &#x27;带伞&#x27; + &#x27;（&#x27; + City.weather(self) + &#x27;，&#x27; + City.temperatureHigh(self) + &#x27;/&#x27; + City.temperatureLow(self) + &#x27;）&#x27; message = MIMEText(&#x27;plain&#x27;, &#x27;utf-8&#x27;) name, addr = parseaddr(city_name+&#x27;带伞提示&lt;%s&gt;&#x27; % account) message[&#x27;From&#x27;] = formataddr((Header(name, &#x27;utf-8&#x27;).encode(), addr)) message[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;) Email_for_city = Email(self.receiver, message.as_string()) try: Email_for_city.Send_Email() print(city_name+&#x27;邮件发送成功&#x27;) except: print(city_name+&#x27;邮件发送失败&#x27;) Email_for_city.Quit_Email() else: if time == &quot;17&quot;: subject = City.weather(self) + &#x27;，&#x27; + City.temperatureHigh(self) + &#x27;/&#x27; + City.temperatureLow(self) message = MIMEText(&#x27;plain&#x27;, &#x27;utf-8&#x27;) name, addr = parseaddr(city_name+&#x27;今日天气&lt;%s&gt;&#x27; % account) message[&#x27;From&#x27;] = formataddr((Header(name, &#x27;utf-8&#x27;).encode(), addr)) message[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;) Email_for_city = Email(self.receiver, message.as_string()) try: Email_for_city.Send_Email() print(city_name+&#x27;邮件发送成功&#x27;) except: print(city_name+&#x27;邮件发送失败&#x27;) Email_for_city.Quit_Email() 整体框架123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import requestsfrom bs4 import BeautifulSoupimport smtplibfrom email.mime.text import MIMETextfrom email.header import Headerfrom email.utils import parseaddr, formataddrimport datetimecity_dict = &#123;&#x27;深圳市&#x27;: &#x27;101280601&#x27;, &#x27;城市2&#x27;: &#x27;城市2代码&#x27;&#125;receiver_addr = [&#x27;收件人1邮箱&#x27;, &#x27;收件人2邮箱&#x27;]account = &quot;发件人邮箱&quot;password = &quot;发件人授权码&quot;def getDictKey(myDict, value): for k, v in myDict.items(): if v == value: return kclass Email: def __init__(self, receiver, message): self.receiver = receiver self.message = message mailhost = &#x27;smtp.qq.com&#x27; Email.qqmail = smtplib.SMTP() Email.qqmail.connect(mailhost, 25) def Send_Email(self): Email.qqmail.login(account, password) Email.qqmail.sendmail(account, self.receiver, self.message) def Quit_Email(self): Email.qqmail.quit()class City: def __init__(self, city_code, receiver): self.city_code = city_code self.receiver = receiver headers = &#123;&#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36 Edg/89.0.774.68&#x27;&#125; url = &#x27;http://www.weather.com.cn/weather/&#x27; + self.city_code + &#x27;.shtml&#x27; res = requests.get(url, headers=headers) res.encoding = &#x27;utf-8&#x27; City.soup = BeautifulSoup(res.text, &#x27;html.parser&#x27;) City.tagToday = City.soup.find(&#x27;p&#x27;, class_=&quot;tem&quot;) def temperatureHigh(self): try: tempHigh = City.tagToday.span.string return tempHigh except AttributeError as e: tempHigh = City.tagToday.find_next(&#x27;p&#x27;, class_=&quot;tem&quot;).span.string return tempHigh def temperatureLow(self): tempLow = City.tagToday.i.string return tempLow def weather(self): weather = City.soup.find(&#x27;p&#x27;, class_=&quot;wea&quot;).string return weather def Email_send_discriminant(self): time = datetime.datetime.now().strftime(&#x27;%H&#x27;) city_name = getDictKey(city_dict, self.city_code) if City.weather(self).text.find(u&quot;雨&quot;) != -1 or City.weather(self).text.find(u&quot;雾&quot;) != -1 or City.weather(self).text.find( u&quot;雹&quot;) != -1 or City.weather(self).text.find(u&quot;雪&quot;) != -1: if time == &quot;07&quot; or time == &quot;17&quot;: subject = &#x27;带伞&#x27; + &#x27;（&#x27; + City.weather(self) + &#x27;，&#x27; + City.temperatureHigh(self) + &#x27;/&#x27; + City.temperatureLow(self) + &#x27;）&#x27; message = MIMEText(&#x27;plain&#x27;, &#x27;utf-8&#x27;) name, addr = parseaddr(city_name+&#x27;带伞提示&lt;%s&gt;&#x27; % account) message[&#x27;From&#x27;] = formataddr((Header(name, &#x27;utf-8&#x27;).encode(), addr)) message[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;) Email_for_city = Email(self.receiver, message.as_string()) try: Email_for_city.Send_Email() print(city_name+&#x27;邮件发送成功&#x27;) except: print(city_name+&#x27;邮件发送失败&#x27;) Email_for_city.Quit_Email() else: if time == &quot;08&quot;: subject = City.weather(self) + &#x27;，&#x27; + City.temperatureHigh(self) + &#x27;/&#x27; + City.temperatureLow(self) message = MIMEText(&#x27;plain&#x27;, &#x27;utf-8&#x27;) name, addr = parseaddr(city_name+&#x27;今日天气&lt;%s&gt;&#x27; % account) message[&#x27;From&#x27;] = formataddr((Header(name, &#x27;utf-8&#x27;).encode(), addr)) message[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;) Email_for_city = Email(self.receiver, message.as_string()) try: Email_for_city.Send_Email() print(city_name+&#x27;邮件发送成功&#x27;) except: print(city_name+&#x27;邮件发送失败&#x27;) Email_for_city.Quit_Email()if __name__ == &#x27;__main__&#x27;: ShenZhen = City(city_dict[&#x27;深圳市&#x27;], receiver_addr[0]) ShenZhen.Email_send_discriminant() city_2 = City(city_dict[&#x27;城市2&#x27;], receiver_addr[1]) city_2.Email_send_discriminant() print(&quot;时间:&quot; + datetime.datetime.now().strftime(&#x27;%Y.%m.%d-%H.%M.%S&#x27;)) 创建定时任务使用Ubuntu中的定时任务管理器crontab编辑定时任务 1crontab -e 显示7:30，8:15，17:58执行脚本的任务 1crontab -l 效果 written by：航&#x2F;2021&#x2F;11&#x2F;18","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yuhang-blog.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yuhang-blog.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"nfs远程目录挂载","slug":"nfs","date":"2021-10-22T09:52:32.000Z","updated":"2021-12-29T09:52:28.000Z","comments":true,"path":"2021/10/22/nfs/","link":"","permalink":"http://yuhang-blog.github.io/2021/10/22/nfs/","excerpt":"前言NFS：网络文件系统。手头上有两台设备，一台运行着Ubuntu系统的虚拟机，另一个是运行着Ubuntu系统的Nanopi。需要将虚拟机中的文件导入至Nanopi中，为了方便文件的传输，两台主机分别安装nfs服务端和nfs客户端，通过局域网让两台主机系统之间共享文件。将虚拟机中的共享文件目录挂载到Nanopi的本地文件目录中","text":"前言NFS：网络文件系统。手头上有两台设备，一台运行着Ubuntu系统的虚拟机，另一个是运行着Ubuntu系统的Nanopi。需要将虚拟机中的文件导入至Nanopi中，为了方便文件的传输，两台主机分别安装nfs服务端和nfs客户端，通过局域网让两台主机系统之间共享文件。将虚拟机中的共享文件目录挂载到Nanopi的本地文件目录中 服务端 安装 在虚拟机中安装rpcbind服务器及nfs服务器 1sudo apt-get install rpcbind 1sudo apt-get install nfs-kernel-server 配置 打开配置文件 1sudo vim /etc/exports 编辑配置文件，在最后一行加上 1/home/yuhang/nfs *(rw,sync,no_root_squash,no_subtree_check) 各个参数之间的含义： &#x2F;home&#x2F;yuhang&#x2F;nfs： 为nfs服务端共享的目录 *：允许所有的网段访问，也可以使用具体的IP rw：nfs客户端对该共享目录具有读写权限 sync：资料同步写入内存和硬盘 no_root_squash：root用户具有对根目录的完全管理访问权限。 no_subtree_check：不检查父目录的权限。 设置共享目录的权限 1sudo chmod -R 777 /home/yuhang/nfs 重新启动服务 1sudo service rpcbind start 1sudo /etc/init.d/nfs-kernel-server restart 客户端 安装 在Nanopi中nfs客户端 1sudo apt-get install nfs-common 挂载 将服务端的共享目录中的内容挂载到客户端文件目录中 1sudo mount -t nfs -o nolock 192.168.?.?:/home/yuhang/nfs /root/nfs 192.168.?.?：为虚拟机的IP地址 &#x2F;root&#x2F;nfs：为客户端的文件目录(不要在此文件目录输入此命令) 测试在Naopi中的&#x2F;root&#x2F;nfs目录中输入ls查看是否存在和虚拟机中&#x2F;home&#x2F;yuhang&#x2F;nfs相同的文件。 written by：航&#x2F;2021&#x2F;10&#x2F;22","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yuhang-blog.github.io/tags/linux/"}]},{"title":"四种“1+1=2”","slug":"FourTypes","date":"2021-09-01T10:52:32.000Z","updated":"2021-12-27T01:08:08.000Z","comments":true,"path":"2021/09/01/FourTypes/","link":"","permalink":"http://yuhang-blog.github.io/2021/09/01/FourTypes/","excerpt":"引言日子转呀转，转到九月一日，转眼到了熊孩子开学的日子，也很久没更新了，那就划划水吧！那就用“四种语言”实现1+1&#x3D;2，希望自己在“新学期”里能将所有的挑战化为1+1&#x3D;2。打开SSH软件，输入IP地址和端口号开启远程登录，输入账号密码进入个人服务器，进入项目目录，开始1+1","text":"引言日子转呀转，转到九月一日，转眼到了熊孩子开学的日子，也很久没更新了，那就划划水吧！那就用“四种语言”实现1+1&#x3D;2，希望自己在“新学期”里能将所有的挑战化为1+1&#x3D;2。打开SSH软件，输入IP地址和端口号开启远程登录，输入账号密码进入个人服务器，进入项目目录，开始1+1 C语言1234567891011121314151617181920root@NanoPi-NEO:~/workspace# lsc c++ python shellroot@NanoPi-NEO:~/workspace# cd croot@NanoPi-NEO:~/workspace/c# vim 1.croot@NanoPi-NEO:~/workspace/c# cat -n 1.c 1 #include &lt;stdio.h&gt; 2 int main() 3 &#123; 4 int a=0,b=0; 5 printf(&quot;请输入两个数:\\n&quot;); 6 scanf(&quot;%d %d&quot;,&amp;a,&amp;b); 7 printf(&quot;%d+%d=%d\\n&quot;,a,b,a+b); 8 return 0; 9 &#125;root@NanoPi-NEO:~/workspace/c# gcc 1.c -o 1root@NanoPi-NEO:~/workspace/c# ./1请输入两个数:1 11+1=2root@NanoPi-NEO:~/workspace/c# C++1234567891011121314151617181920root@NanoPi-NEO:~/workspace# lsc c++ python shellroot@NanoPi-NEO:~/workspace# cd c++root@NanoPi-NEO:~/workspace/c++# vim 1.cpproot@NanoPi-NEO:~/workspace/c++# cat -n 1.cpp 1 #include &lt;iostream&gt; 2 int main() 3 &#123; 4 int a=0,b=0; 5 std::cout &lt;&lt; &quot;请输入两个数:&quot; &lt;&lt; std::endl; 6 std::cin &gt;&gt; a &gt;&gt; b; 7 std::cout &lt;&lt; a &lt;&lt; &#x27;+&#x27; &lt;&lt; b &lt;&lt; &#x27;=&#x27; &lt;&lt; a+b &lt;&lt; std::endl; 8 return 0; 9 &#125;root@NanoPi-NEO:~/workspace/c++# g++ 1.cpp -o 1root@NanoPi-NEO:~/workspace/c++# ./1请输入两个数:1 11+1=2root@NanoPi-NEO:~/workspace/c++# Python123456789101112root@NanoPi-NEO:~/workspace# lsc c++ python shellroot@NanoPi-NEO:~/workspace# cd pythonroot@NanoPi-NEO:~/workspace/python# vim 1.pyroot@NanoPi-NEO:~/workspace/python# cat -n 1.py 1 a,b = map(int,input(&#x27;请输入两个数:\\n&#x27;).split()) 2 print(&quot;&#123;&#125;+&#123;&#125;=&#123;&#125;&quot;.format(a,b,a+b))root@NanoPi-NEO:~/workspace/python# python3 1.py请输入两个数:1 11+1=2root@NanoPi-NEO:~/workspace/python# Shell1234567891011121314root@NanoPi-NEO:~/workspace# lsc c++ python shellroot@NanoPi-NEO:~/workspace# cd shellroot@NanoPi-NEO:~/workspace/shell# vim 1.shroot@NanoPi-NEO:~/workspace/shell# cat -n 1.sh 1 #!/bin/bash 2 read -p $&#x27;请输入两个数:\\n&#x27; a b 3 echo &quot;$a+$b=$[ $a+$b ]&quot;root@NanoPi-NEO:~/workspace/shell# chmod +x 1.shroot@NanoPi-NEO:~/workspace/shell# ./1.sh请输入两个数:1 11+1=2root@NanoPi-NEO:~/workspace/shell# 总结入秋已凉，“新学期”也要注意身体！ written by：航&#x2F;2021&#x2F;9&#x2F;1","categories":[],"tags":[{"name":"划水篇","slug":"划水篇","permalink":"http://yuhang-blog.github.io/tags/%E5%88%92%E6%B0%B4%E7%AF%87/"}]},{"title":"python实现RSA签名及验签","slug":"rsa-python","date":"2021-08-23T12:42:48.000Z","updated":"2021-08-31T03:18:48.000Z","comments":true,"path":"2021/08/23/rsa-python/","link":"","permalink":"http://yuhang-blog.github.io/2021/08/23/rsa-python/","excerpt":"前言上篇RSA算法的初始，本篇将使用python实现签名和验签的流程","text":"前言上篇RSA算法的初始，本篇将使用python实现签名和验签的流程 私钥及公钥生成流程123456789101112131415161718from Crypto import Randomfrom Crypto.PublicKey import RSA# 生成随机数random_gen = Random.new().read# 利用随机数创建1024长度的秘钥对象rsa = RSA.generate(1024, random_gen)# 获取私钥并保存private_pem = rsa.export_key()with open(&#x27;private_pem&#x27;, &#x27;wb&#x27;) as f: f.write(private_pem)# 获取公钥并保存public_pem = rsa.public_key().export_key()with open(&#x27;public_pem&#x27;, &#x27;wb&#x27;) as f: f.write(public_pem) 私钥123456789101112131415-----BEGIN RSA PRIVATE KEY-----MIICXAIBAAKBgQCfR2xXNSa84oQbufF+TOzCibSbqMlB8HKdymbpamcq5zV6qnTk0NxxAXWFd2EoOenif+3qkrJ8xGUMJSutrPx+AB/y+MfzMIKAqq3QYjk/P9CW4ej21cOVoA8of962t71c7Pioa1esVsS0QJJNSvQPX00dm03k8Uc34LUolxWy3QIDAQABAoGACQeViW7GnsKrVp8N+mkGAGlUxyukbTaNE4ub60j68aBglG8BaCS8ZTOoo+5b9a8te90LcdbrLiOReZofMHNexPb0LliCaQBQAZFmkb0A792jsbriORpeR5r6yQyZnA3ojogPA9f08Ur10TKq64RyGDiB9GrW3c8YV2duvmN0q0ECQQC//vI1e+qjqN2DsZhOZrjal1Jhs91YD8TsXDB+Nl7uimph1crEsGt7kuKXxgAzLA+G5QuFiiwjCT24KqCNcg/lAkEA1GBli1dSRfKidUvW0J4k7QpF1sywQeQA8Il8npMfFqaJlXUBdbk4UaHkLxso/DNZ7ge5veSRNi8yiYBYkoA3mQJAQ9ic0MecT/8hYCNG9hWYpy4oH3yG8FKKPRgKzt75xwPEuhPpln3dTYrHZejDM1ITnpCb9LGyDSN72vO9Tp6K/QJBALYS9ruhX12siO86163/BvVZy0o+LhYvXUba+EYTJ6IJoQbLSzccVlZWDwT7qgWeGMljQjC01nG3wQH1UPo4hnECQAtdPt49s7FtVavc0EChgZ70mMPMOiHZw3fupPJ7JSrQvekjQtvrdJkOE4DcWdEgaRlHmsiFaTAZeuYgmrqQj9w=-----END RSA PRIVATE KEY----- 公钥123456-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCfR2xXNSa84oQbufF+TOzCibSbqMlB8HKdymbpamcq5zV6qnTk0NxxAXWFd2EoOenif+3qkrJ8xGUMJSutrPx+AB/y+MfzMIKAqq3QYjk/P9CW4ej21cOVoA8of962t71c7Pioa1esVsS0QJJNSvQPX00dm03k8Uc34LUolxWy3QIDAQAB-----END PUBLIC KEY----- 签名流程123456789101112131415161718192021222324252627282930from Crypto.PublicKey import RSAfrom Crypto.Hash import SHAfrom Crypto.Signature import pkcs1_15 as sigimport base64# 发送的消息name = &quot;欢迎来到航的个人站&quot;# 获取私钥key = open(&#x27;private_pem&#x27;, &#x27;r&#x27;).read()private_key = RSA.importKey(key)# 根据哈希函数中的SHA算法生成消息摘要digest = SHA.new(name.encode())# 使用私钥对消息摘要进行加密为签名sig_pk = sig.new(private_key)sign = sig_pk.sign(digest)# 将签名转换为base64编码sign = base64.b64encode(sign)# 将签名转换成字符串sign = sign.decode()print(sign)# 将签名存放到文件中textfile = open(&#x27;sign.txt&#x27;, &#x27;w&#x27;)textfile.write(sign)textfile.close() 生成的签名1qVO/2yZgJM7un4NHsQDolodRzx+tc/yt8pCsyg5hhg4MOJVsOEUd+dwguZiHir/f/ED0stELXGVkBQpUCmhKkDBpztqODDEQTEzRUBm+uxmKbpYjIU7m1hmd0Y4Cw+FFF8nh1HOnqyrP87rkH2iHCvZ9hy8HiXigigzkuyemXAUQDbb41e6pKllQPIWaxPUSIMA5/lEV9rgWDI8UMbLJVC/W4c7O7BA86fXLBsTvcffhInzPlM3yWBr0zsmOzccq8TZtqUP5/S0xF1Rt6Co7xO3bMpXTt/ZgzamXN7EBVXKc9u0Ven16etZ66ELFxNHyxiRD52wVCWegHhl7FCFBXA== 验签流程12345678910111213141516171819202122232425262728293031from Crypto.Hash import SHAfrom Crypto.Signature import pkcs1_15 as sigfrom Crypto.PublicKey import RSAimport base64# 接收的内容name = &quot;欢迎来到航的个人站&quot;# 读取签名sign = open(&#x27;sign.txt&#x27;, &#x27;r&#x27;).read()# 将签名进行base64解码sign = base64.b64decode(sign)# 获取公钥key = open(&#x27;public_pem&#x27;, &#x27;r&#x27;).read()public_key = RSA.import_key(key)# 根据哈希函数中的SHA算法生成消息摘要digest = SHA.new(name.encode())# 使用公钥验证签名signer = sig.new(public_key)result = signer.verify(digest, sign)# 输出验证结果# print(result)if result is True: print(&#x27;验签成功&#x27;)else: print(&#x27;验签失败&#x27;) 验签结果123验签成功进程已结束,退出代码0 总结验签函数是验证成功程序会直接结束，验证失败会抛出一个错误，此处被我修改成返回布尔量 written by：航&#x2F;2021&#x2F;8&#x2F;23","categories":[],"tags":[{"name":"RSA算法","slug":"RSA算法","permalink":"http://yuhang-blog.github.io/tags/RSA%E7%AE%97%E6%B3%95/"},{"name":"Python","slug":"Python","permalink":"http://yuhang-blog.github.io/tags/Python/"}]},{"title":"RSA算法的初识","slug":"rsa","date":"2021-08-12T10:48:27.000Z","updated":"2021-08-31T03:18:22.000Z","comments":true,"path":"2021/08/12/rsa/","link":"","permalink":"http://yuhang-blog.github.io/2021/08/12/rsa/","excerpt":"RSA算法原理寻找两个大素数，将它们的乘积公开作为加密密钥，寻找两个大素数简单，但是将他们的乘积进行因式分解很困难","text":"RSA算法原理寻找两个大素数，将它们的乘积公开作为加密密钥，寻找两个大素数简单，但是将他们的乘积进行因式分解很困难 RSA算法使用RSA算法有两种使用方法，一种是：公钥加密，私钥解密，另一种是：私钥加密，公钥解密 加密&#x2F;解密 苏珊需要和鲍勃进行加密通信，鲍勃制作了一对RSA密钥，私钥给自己用，公钥给苏珊用 苏珊给鲍勃写了一封信，使用了鲍勃的公钥进行加密 鲍勃收到加密信，使用自己的私钥进行解密看到信件内容 签名&#x2F;验签 鲍勃给苏珊写回信，利用哈希函数将消息生成消息摘要 鲍勃利用自己的私钥对消息摘要进行加密生成数字签名 鲍勃将回信和数字签名一起发送给苏珊 苏珊收到来信后，利用鲍勃的公钥将数字签名进行解密得到消息摘要，苏珊可以判定此信为鲍勃发送的(公钥无法签名) 苏珊利用哈希函数将消息生成消息摘要，然后利用此消息摘要和公钥解密的消息摘要进行比较，如果两个消息摘要相同则消息未被篡改 数字签名保证了数据的完整性和发送角色的不可抵赖性 哈希函数哈希函数就是能将任意长度的数据映射为固定长度的数据的函数。哈希函数返回的值被叫做哈希值 消息摘要将长度不固定的消息作为输入参数，运行特定的Hash函数，生成固定长度的输出，这个输出就是Hash，也称为这个消息的消息摘要 消息摘要算法是hash算法的一种，具有以下特点： 无论输入的消息有多长，计算出来的消息摘要的长度总是固定的，计算出的结果越长，一般认为该摘要算法越安全 输入的消息不同，产生的消息摘要必不同，输入的消息相同，产生的消息摘要一定是相同的 单向不可逆 结尾对RSA算法有了大致了解之后，下篇利用python实现签名和验签的过程 written by：航&#x2F;2021&#x2F;8&#x2F;12","categories":[],"tags":[{"name":"RSA算法","slug":"RSA算法","permalink":"http://yuhang-blog.github.io/tags/RSA%E7%AE%97%E6%B3%95/"},{"name":"学习篇","slug":"学习篇","permalink":"http://yuhang-blog.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AF%87/"}]},{"title":"Nanopi NEO建立内网访问的博客","slug":"Nanopi-Intranet","date":"2021-08-09T14:56:44.000Z","updated":"2021-12-29T09:55:58.000Z","comments":true,"path":"2021/08/09/Nanopi-Intranet/","link":"","permalink":"http://yuhang-blog.github.io/2021/08/09/Nanopi-Intranet/","excerpt":"内网访问博客流程上篇已经实现在Nanopi NEO上运行Ubuntu系统，实现内网访问博客必须要有个服务器，在Nanopi NEO中下载一个服务器，将网页文件导入使其运行，获取Nanopi NEO的IP地址，在浏览器中输入IP地址，即可看到自己的博客","text":"内网访问博客流程上篇已经实现在Nanopi NEO上运行Ubuntu系统，实现内网访问博客必须要有个服务器，在Nanopi NEO中下载一个服务器，将网页文件导入使其运行，获取Nanopi NEO的IP地址，在浏览器中输入IP地址，即可看到自己的博客 Nginx服务器Nginx是一个高性能的HTTP和反向代理web服务器，其特点是占有内存少，并发能力强 安装Nginx服务器 1sudo apt-get install nginx 修改Nginx的配置文件 1sudo vi /etc/nginx/sites-available/default 修改存放网页的路径，&#x2F;home&#x2F;pi&#x2F;WorkSpace&#x2F;Web&#x2F;www，此路径为我创建并存放网页的路径 12345678# Don&#x27;t use them in a production server! # # include snippets/snakeoil.conf; root /home/pi/WorkSpace/Web/www; # Add index.php to the list if you are using PHP index index.html index.htm index.nginx-debian.html; 修改文件权限 将网页的加载路径修改之后会导致Nignx无法加载网页，经过查阅及个人多次试验发现导致此现象的情况为Nignx没有权限访问文件夹里面的内容，所有需要修改文件夹的权限 1sudo chmod a+x /home 1sudo chmod a+x /home/pi 加载Nginx的配置 修改配置文件后，需重新加载配置文件 1sudo /etc/init.d/nginx reload 启动Nginx启动Nginx前先将网页文件导入至配置文件中的网页文件存放路径 1sudo /etc/init.d/nginx start 关闭Nginx 1sudo /etc/init.d/nginx stop 导入网页文件上篇提到如何获取Nano pi的IP地址，这时使用FTP协议即可将网页文件导入Nanopi NEO的&#x2F;home&#x2F;pi&#x2F;WorkSpace&#x2F;Web&#x2F;www中，传输工具选用FileZilla 软件界面 软件界面如下 传输过程 输入IP地址，用户名，密码，端口为22即可连接并传输文件 内网访问博客启动Nginx后，在浏览器中输入IP地址即可访问到博客了 总结内网访问的过程还是比较简单的，这还只是个开始，此时博客的状态还只能在局域网内访问，别人是无法访问的。拖更这么久终于抽空把内网访问的教程写完。 written by：航&#x2F;2021&#x2F;8&#x2F;9","categories":[],"tags":[{"name":"blog","slug":"blog","permalink":"http://yuhang-blog.github.io/tags/blog/"},{"name":"Nanopi NEO","slug":"Nanopi-NEO","permalink":"http://yuhang-blog.github.io/tags/Nanopi-NEO/"}]},{"title":"Naopi NEO三种登录方式","slug":"Nanopi-login","date":"2021-08-03T13:48:24.000Z","updated":"2021-12-29T09:55:32.000Z","comments":true,"path":"2021/08/03/Nanopi-login/","link":"","permalink":"http://yuhang-blog.github.io/2021/08/03/Nanopi-login/","excerpt":"前言使用Naopi NEO之前需要将Ubuntu系统刷入其内，然后输入用户名和密码进行开发。官网有烧录教程和镜像，这里就不多说，仔细讲讲官网没有的登录方式。一种有线连接和两种无线连接分别为：UART连接，SSH连接，VNC连接","text":"前言使用Naopi NEO之前需要将Ubuntu系统刷入其内，然后输入用户名和密码进行开发。官网有烧录教程和镜像，这里就不多说，仔细讲讲官网没有的登录方式。一种有线连接和两种无线连接分别为：UART连接，SSH连接，VNC连接 Ubuntu镜像烧录Ubuntu镜像烧录可以查看友善之臂官网教程，按官网教程烧录。提醒：烧录完成后系统提示将SD卡格式化，不要格式化直接弹出SD卡即可，官网没有提醒此事 UART登录镜像烧录完成后使用PUTTY软件中的串口连接登录，PUTTY_是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件 配置界面 连接方式选择串口连接，串口使用自己的端口，波特率选115200 登录界面 串口连接好之后登录账号密码即可看到如下画面代表成功进入系统，输入以下命令即可看到IP地址。进入系统即可写shell脚本了。这种登录方式一定要有线连接，比较麻烦 1ifconfig SSH登录插入网线，串口登录后使用ifconfig获取Naonopi NEO的IP地址后，还是使用PUTTY软件登录 配置界面 连接方式选择SSH连接，填入IP地址，端口填22。 登录界面 IP地址填写正确之后登录账号密码即可看到如下画面代表成功进入系统，进入系统即可写shell脚本了。这种登录方式为无线连接，比较方便 VNC+xfce4登录上面两种方式登录后开发是没有图形界面的，此Ubuntu镜像默认不带图形界面。因此需先安装xfce4搭建桌面环境，然后利用VNC远程连接从而实现远程桌面，windows端或者手机端下载VNC Viewer软件进行远程连接Nanopi NEO。利用SSH连接输入以下命令进行VNC+xfce4的登录的配置 安装cfce4 1sudo apt-get install xfce4 安装VNC 1sudo apt-get install vncserver 设置VNC连接密码 1vncpasswd 修改VNC配置文件 1sudo vi .vnc/xstartup 输入以上命令后按i键进入配置文件，将配置文件改成以下格式，使得VNC启动时调用xfce4加载桌面 12345678910#!/bin/sh unset SESSION_MANAGER exec /etc/X11/xinit/xinitrc [ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup [ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresources xsetroot -solid grey vncconfig -iconic &amp; xfce4-session &amp; 按ESC退出编辑模式，输入：wq保存并退出，保存并退出后输入以下命令修改启动文件权限 1sudo chmod +x ~/.vnc/xstartup 启动VNC进程 1vncserver :1 结束VNC进程 1vncserver -kill :1 配置界面 输入IP地址和设置的VNC连接密码进入远程桌面 windows端登录界面 进入到以下界面，VNC+xfce4登录的远程桌面就搭建完成了，可以在Ubuntu桌面内进行开发了。操作起来非常顺畅，此刻Nanopi NEO成为了超mini电脑了 手机端登录界面 手机端通过VNC与Nanopi NEO连接进行远程桌面操作起来依旧非常流畅，在不想打开电脑时可以利用手机登录 重启输入此条命令可以使Naonopi NEO重启 1reboot 关机输入此条命令可以使Naonopi NEO立刻关机 1shutdown -h now 总结在对Nanopi NEO进行远程桌面连接时，多次出现桌面灰屏，查阅了大量资料总结出以上配置流程才将VNC配置文件修改好。现Naonopi已成功注入灵魂，将博客重新部署指日可待 written by：航&#x2F;2021&#x2F;8&#x2F;3","categories":[],"tags":[{"name":"Naopi NEO","slug":"Naopi-NEO","permalink":"http://yuhang-blog.github.io/tags/Naopi-NEO/"}]},{"title":"Nanopi NEO开箱图文","slug":"nanopi","date":"2021-08-02T14:21:26.000Z","updated":"2021-12-29T09:55:02.000Z","comments":true,"path":"2021/08/02/nanopi/","link":"","permalink":"http://yuhang-blog.github.io/2021/08/02/nanopi/","excerpt":"前言将博客部署在github上，由于使用的是国外服务器，使得博客加载缓慢。于是萌生了自己搭建一个服务器的想法，使用电脑当服务器或者使用云服务器有点大材小用，浪费资源和成本太高。使用一个能运行Ubuntu系统并且价格便宜的开发板能够完美解决此问题","text":"前言将博客部署在github上，由于使用的是国外服务器，使得博客加载缓慢。于是萌生了自己搭建一个服务器的想法，使用电脑当服务器或者使用云服务器有点大材小用，浪费资源和成本太高。使用一个能运行Ubuntu系统并且价格便宜的开发板能够完美解决此问题 介绍Nanopi NEO是FriendlyARM(友善之臂)开发的一款小巧的开发板。此开发板非常mini，插上网线和电源放在角落完全不占地方，并且全志H3芯片的性能完全够用。 主要硬件规格 CPU：全志 H3，四核 Cortex-A7 高达 1.2GHz DDR3 内存：256MB&#x2F;512MB 网口：10&#x2F;100M以太网 USB ：A 型 x 1 MicroSD ：插槽 x 1 主要软件功能 Linux Ubuntu Android 尺寸图Nanopi NEO的PCB尺寸小至40×40毫米 开箱Nanopi NEO包装分为：一个包装壳，一份全英文说明书，一个开发板 包装壳包装壳是以绿色为基调的包装壳，看起来很健康。包装壳上印上大大的π，其slogan和官网地址 说明书说明书为一份全英文说明书，简单的介绍了Nanopi NEO的使用方法 开发板开发板很小巧，只有几个硬币一样大。开发板正面可以看到四个接口：网口、USB口、电源口、SD卡插槽，背面可以看到全志H3CPU和内存 正面展示a 正面展示b 侧面展示 背面展示a 背面展示b 预告开发板已到手，接下来的时间就是给Nanopi NEO注入灵魂的时刻，下篇内容为将博客部署在Nanopi NEO上 written by：航&#x2F;2021&#x2F;8&#x2F;2","categories":[],"tags":[{"name":"Nanopi NEO","slug":"Nanopi-NEO","permalink":"http://yuhang-blog.github.io/tags/Nanopi-NEO/"},{"name":"图文介绍","slug":"图文介绍","permalink":"http://yuhang-blog.github.io/tags/%E5%9B%BE%E6%96%87%E4%BB%8B%E7%BB%8D/"}]},{"title":"Markdown文本编辑器的使用","slug":"Typora","date":"2021-07-31T06:44:25.000Z","updated":"2021-08-31T03:19:10.000Z","comments":true,"path":"2021/07/31/Typora/","link":"","permalink":"http://yuhang-blog.github.io/2021/07/31/Typora/","excerpt":"前言博客服务器搭建完成后，如何写博客非常重要，推荐的Markdown文本编辑器为Typora。具有界面简洁和使用简单等特点","text":"前言博客服务器搭建完成后，如何写博客非常重要，推荐的Markdown文本编辑器为Typora。具有界面简洁和使用简单等特点 Typora界面 标题六种标题的显示效果如下： 一级标题二级标题三级标题四级标题五级标题六级标题 六种标题的快捷键如下： 123456Ctrl+1Ctrl+2Ctrl+3Ctrl+4Ctrl+5Ctrl+6 列表有序列表有序排序的显示效果如下： 一 二 三 有序排序的快捷键如下： 123Ctrl+Shift+&#123; ##新建有序列表Tab ##生成子列表Shift+Tab ##返回上一级列表 无序列表无序列表的显示效果如下： 一 二 三 无序列表的快捷键如下： 1Ctrl+Shift+&#125; ##新建无序列表 超链接点击此处进入Typora官网，可以在官网下载此软件。超链接的使用方法如下： 1[点击此处进入Typora官网](https://typora.io/) 划重点划重点可以从Typora软件中格式中调整，效果如下： 加粗 1234567890 斜体 1234567890 背影 1234567890 下划线 1234567890 删除线 1234567890 表格表格的显示效果如下： 文件&#x2F;文件夹管理命令 Ubuntu系统基本命令 命令含义及介绍 ls 列出当前目录文件（不包括隐含文件） ls -a 列出当前目录文件（包括隐含文件） ls -l 列出当前目录下文件的详细信息 cd .. 回当前目录的上一级目录 cd - 回上一次所在的目录 cd ~ 或 cd 回当前用户的宿主目录 mkdir 目录名 创建一个目录 rmdir 空目录名 删除一个空目录 rm 文件名 文件名 删除一个文件或多个文件 rm -rf 非空目录名 删除一个非空目录下的一切 mv 文件名 新名称 在当前目录下改名 表格的快捷键如下： 1Ctrl+T 视频B站分享链接在分享按钮里面的嵌入代码，添加的视频代码如下： 12345678910&lt;iframe src=&quot;B站分享链接提供&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; height=640 width=1260&gt; &lt;/iframe&gt; 视频显示效果如下： 此视频为Typora的使用教程，感觉不错，分享一下 结语Typora的基本使用方法就介绍到这了 written by：航&#x2F;2021&#x2F;7&#x2F;31","categories":[],"tags":[{"name":"使用方法","slug":"使用方法","permalink":"http://yuhang-blog.github.io/tags/%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"name":"Typora","slug":"Typora","permalink":"http://yuhang-blog.github.io/tags/Typora/"}]},{"title":"你好！世界","slug":"helloworld","date":"2021-01-27T13:30:28.000Z","updated":"2021-08-31T03:15:12.000Z","comments":true,"path":"2021/01/27/helloworld/","link":"","permalink":"http://yuhang-blog.github.io/2021/01/27/helloworld/","excerpt":"博客搭建日志","text":"博客搭建日志 2021&#x2F;1&#x2F;27：完成博客搭建2021&#x2F;7&#x2F;31：修改博客主题并更改博客服务器…………… written by：航&#x2F;2021&#x2F;1&#x2F;27","categories":[],"tags":[{"name":"初始篇","slug":"初始篇","permalink":"http://yuhang-blog.github.io/tags/%E5%88%9D%E5%A7%8B%E7%AF%87/"},{"name":"hello world","slug":"hello-world","permalink":"http://yuhang-blog.github.io/tags/hello-world/"}]}],"categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://yuhang-blog.github.io/tags/test/"},{"name":"LiteOS","slug":"LiteOS","permalink":"http://yuhang-blog.github.io/tags/LiteOS/"},{"name":"FreeRTOS","slug":"FreeRTOS","permalink":"http://yuhang-blog.github.io/tags/FreeRTOS/"},{"name":"callback","slug":"callback","permalink":"http://yuhang-blog.github.io/tags/callback/"},{"name":"C语言","slug":"C语言","permalink":"http://yuhang-blog.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"linux","slug":"linux","permalink":"http://yuhang-blog.github.io/tags/linux/"},{"name":"MinDoc","slug":"MinDoc","permalink":"http://yuhang-blog.github.io/tags/MinDoc/"},{"name":"python","slug":"python","permalink":"http://yuhang-blog.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yuhang-blog.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"划水篇","slug":"划水篇","permalink":"http://yuhang-blog.github.io/tags/%E5%88%92%E6%B0%B4%E7%AF%87/"},{"name":"RSA算法","slug":"RSA算法","permalink":"http://yuhang-blog.github.io/tags/RSA%E7%AE%97%E6%B3%95/"},{"name":"Python","slug":"Python","permalink":"http://yuhang-blog.github.io/tags/Python/"},{"name":"学习篇","slug":"学习篇","permalink":"http://yuhang-blog.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AF%87/"},{"name":"blog","slug":"blog","permalink":"http://yuhang-blog.github.io/tags/blog/"},{"name":"Nanopi NEO","slug":"Nanopi-NEO","permalink":"http://yuhang-blog.github.io/tags/Nanopi-NEO/"},{"name":"Naopi NEO","slug":"Naopi-NEO","permalink":"http://yuhang-blog.github.io/tags/Naopi-NEO/"},{"name":"图文介绍","slug":"图文介绍","permalink":"http://yuhang-blog.github.io/tags/%E5%9B%BE%E6%96%87%E4%BB%8B%E7%BB%8D/"},{"name":"使用方法","slug":"使用方法","permalink":"http://yuhang-blog.github.io/tags/%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"name":"Typora","slug":"Typora","permalink":"http://yuhang-blog.github.io/tags/Typora/"},{"name":"初始篇","slug":"初始篇","permalink":"http://yuhang-blog.github.io/tags/%E5%88%9D%E5%A7%8B%E7%AF%87/"},{"name":"hello world","slug":"hello-world","permalink":"http://yuhang-blog.github.io/tags/hello-world/"}]}